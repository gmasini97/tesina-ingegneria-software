\documentclass{article}
\usepackage[italian]{babel}
\usepackage{titling}
\usepackage[style=ieee]{biblatex}
\usepackage{hyperref}
\usepackage{textcomp}
\usepackage{tabularx}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{comment}
\usepackage{nameref}
\usepackage{float}
\usepackage{wrapfig}
\hypersetup{
    colorlinks,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\addbibresource{108456-masini.bib}
\graphicspath{ {./imgs/} }
\lstset{
  basicstyle=\small,
  breaklines=true
}

\newcommand{\srsnomeprogetto}{GPMS}
\newcommand{\srslongnomeprogetto}{General Purpose Monitoring System}
\newcommand{\srsdbname}{CouchDB}
\newcommand{\srsavlibname}{ffmpeg}

\newcommand{\srswrapfigwidth}{0.44\textwidth}
\newcommand{\srsrtcol}{0.18\linewidth}
\newcommand{\srsrtcoll}{0.32\linewidth}
\newcommand{\srsrtcolll}{0.32\linewidth}
\newcommand{\srsrtmcol}{\the\dimexpr\srsrtcoll+\srsrtcolll+4\tabcolsep+2\arrayrulewidth}
\newcommand{\srsninecelltable}[9]{
    \begin{tabular}{|m{\srsrtcol}|m{\srsrtcoll}|m{\srsrtcolll}|}
        \hline
            #1 & #2 & #3 \\
        \hline
            #4 & \multicolumn{2}{m{\srsrtmcol}|}{#5} \\
        \hline
            #6 & \multicolumn{2}{m{\srsrtmcol}|}{#7} \\
        \hline
            #8 & \multicolumn{2}{m{\srsrtmcol}|}{#9} \\
        \hline
    \end{tabular}

    \bigskip

}
\newcommand{\srsfivecelltable}[5]{
    \begin{tabular}{|m{\srsrtcol}|m{\srsrtcoll}|m{\srsrtcolll}|}
        \hline
            #1 & #2 & #3 \\
        \hline
            #4 & \multicolumn{2}{m{\srsrtmcol}|}{#5} \\
        \hline
    \end{tabular}

    \bigskip

}
\newcommand{\srseitable}[6]{
    \srsninecelltable{EI#1}{#2}{#3}{Descrizione}{#4}{Formato dati}{#5}{Tipo}{#6}    
}
\newcommand{\srsfrtable}[6]{
    \srsninecelltable{RF#1}{#2}{#3}{Input}{#4}{Processo}{#5}{Output}{#6}    
}
\newcommand{\srsnrtable}[4]{
    \srsfivecelltable{RN#1}{#2}{#3}{Descrizione}{#4}    
}

\title{
    \srsnomeprogetto\linebreak
    \large \textit \srslongnomeprogetto \linebreak
    \large Specifica dei requisiti di progetto}
\author{Gabriele Masini \#108456}
\date{2019-12-10 rev.2020-02-10}

\begin{document}
    
\maketitle
\pagenumbering{gobble}
\newpage
\tableofcontents
\newpage
\pagenumbering{arabic}
\section{Preambolo}
Grazie alla diffusione dell'\textit{Internet of Things} e con l'introduzione sul mercato di dispositivi come \textit{Amazon} \textit{Echo} si sono resi disponibili al consumatore una moltitudine di prodotti \textit{smart} tra cui telecamere ip, videocitofoni e sensori di vario genere atti a "digitalizzare" la propria esperienza casalinga.
Che si critichi o no la cosa, questa diffusione di dispositivi rende disponibile all'uomo tecnologie multimediali a basso prezzo.
È esattamente in questo contesto che si inserisce il progetto \textit{\srsnomeprogetto}, il quale si pone come obbiettivo la realizzazione di un sistema di gestione e registrazione dei propri dispositivi \textit{smart} per il monitoraggio di uno o più ambienti.
\section{Introduzione}
\subsection{Scopo}
Il presente documento si riferisce alla definizione e descrizione delle informazioni necessarie per lo sviluppo del progetto \textit{\srsnomeprogetto} e interessa tutte le entità coinvolte nella progettazione, sviluppo e utilizzo dello stesso. Il documento viene redatto secondo le direttive espresse nel \textit{IEEE Recommended Paractice for Software Requirements Specifications} \cite{ieeestd830}, ovvero secondo lo standard \textit{IEEE Std 830-1998}.
\subsection{Campo di applicazione}
Il progetto nominato \textit{\srsnomeprogetto} si inserice nel contesto odierno di forte sviluppo di tecnologie relative all'\textit{Internet of Things} e si pone come obbiettivo la gestione dei dispositivi \textit{smart} multimediali per scopi di monitoraggio e videosorveglianza della propria abitazione, nonché di metodi comuni di registrazione dei sopra menzionati dispositivi. \textit{\srsnomeprogetto} non si interfaccerà utilizzando protocolli proprietari dei singoli produttori, ma utilizzerà protocolli comuni e di pubblico dominio di utilizzo, incluso, ma non limitato a, \textit{http, rtsp, udp}.
\subsection{Definizioni, acronimi, abbreviazioni}
Nel presente documento vengono spesso utilizzate abbreviazioni e acronimi comuni nel contesto di sviluppo del progetto. Di seguito vengono riportate le interpretazioni delle suddette abbreviazioni:
\begin{center}
    \begin{tabularx}{\linewidth}{|l X|}
        \hline
        Amministratore & Persona o ente responsabile del mantenimento del \textit{Server}. Spesso è anche un \textit{Client}.\\
        \hline
        Browser Web & Programma destinato alla visualizzazione e navigazione di pagine web (ipertesti).\\
        \hline
        Client & Elaboratore che si collega ad un \textit{Server} per poter usufruire dei servizi da esso offerti. \\
        \hline
        HTTP & \textit{Hypertext Trasfer Protocol}. Protocollo di trasferimento di documenti ipertestuali tramite web.\\
        \hline
        IOT & "Internet of Things", l'aggregazione in internet di dispositivi di poca capacità di calcolo destinati come controllori per determinati elettrodomestici o utilizzati come sensori (telecamere, termometri, microfoni etc). \\
        \hline
        Java & Linguaggio orientato agli oggetti sviluppato da Sun Microsystems e successivamente acquisito da Oracle.\\
        \hline
        Java Virtual Machine (JVM) & Programma destinato all'interpretazione del bytecode di un programma Java.\\
        \hline
        JSON \cite{json} & Rappresentazione di dati eterogenei tramite oggetti \textit{Javascript}.\\
        \hline
        Server & Elaboratore che gestisce in modo centralizzato un insieme di dati e espone una interfaccia per interagire con più \textit{Client} tramite uno o più protocolli. \\
        \hline
        Sistema Operativo & Programma destinato alla gestione delle risorse e sotto-programmi di un elaboratore..\\
        \hline
        Stream & Flusso di dati di vario tipo (audio, video, audio-video etc). \\
        \hline
        Utente & Persona o ente che tramite un \textit{Client} utilizza l'applicazione. \\
        \hline
    \end{tabularx}
\end{center}
\subsection{Riferimenti}
\printbibliography[heading=none]
\subsection{Vista d'insieme del documento}
Il presente documento contiene le specifiche e le relative descrizioni dei requisiti del progetto \textit{\srsnomeprogetto}. Il progetto viene inquadrato secondo quanto citato in questa sezione e si prosegue nella sezione successiva a descriverne la prospettiva e le funzionalità, nonché la caratterizzazione dei potenziali utenti, dei vincoli e delle dipendenze. Nella sezione \textit{\hyperref[sec:specifica]{Specifica dei requisiti}}, verranno spiegate le interfacce con l'esterno e i requisiti funzionali e non.
Alla fine del documento, in \textit{\hyperref[sec:appendice]{Appendice}}, verranno inseriti diagrammi e grafici per integrare quanto detto nelle prossime sezioni, oltre a proporre un possibile utilizzo dei celeberrimi \textit{design pattern} \cite{designpatterns} per la programmazione ad oggetti del progetto.
\section{Descrizione generale}
\subsection{Prospettiva del prodotto}
Il progetto \textit{\srsnomeprogetto} è inteso come una applicazione \textit{stand alone} programmata in \textit{Java} che permetta di gestire una aggregazione di dispositivi atti a monitorare lo stato di uno o più ambienti (ad esempio: una abitazione, un ufficio, un parco etc). L'applicazione è un programma che viene eseguito su una macchina \textit{Server} ed essa espone all'esterno una interfaccia web (\textit{http}) per l'interazione con l'utente; inoltre il programma presenta una interfaccia sul server di tipo ``a riga di comando'' per la gestione da parte dell'amministratore.

\begin{comment}
La natura di Java permette che la applicazione sia \textit{cross-platform} in modo da supportare ambienti Microsoft Windows, Linux e macOS. Anche se Java permette l'utilizzo della applicazione su piattaforme diverse, le uniche supportate ufficialmente dal progetto sono le 3 sopra citate con riferimento a macchine ad architettura \textit{x86} e \textit{amd64}.
\end{comment}

Il software utilizza un database \textit{\srsdbname} per la memorizzazione dei dati degli utenti e delle risorse. Per quanto concerne l'elaborazione degli \textit{stream} audio e video, l'applicazione si avvale del progetto \textit{\srsavlibname}. L'applicazione necessita di almeno una interfaccia di rete installata e configurata correttamente sulla macchina \textit{Server} per la comunicazione coi dispositivi da monitorare, l'accesso da parte dei \textit{Client} e la connessione al servizio di database (nel caso questo sia installato su una macchina remota).

Il \textit{Server} deve disporre di sufficiente spazio di archiviazione per la memorizzazione dei dati temporali dei vari dispositivi (ad esempio: registrazioni video, registrazioni audio, andamento dei sensori etc) per il periodo di mantenimento indicato dall'amministratore. Per completezza è disponibile anche l'archiviazione su server esterno via rete internet, anche se il suo utilizzo è sconsigliato per enti e privati che non dispongono di una banda larghissima in upload, la quale è necessaria per il trasporto di stream di grandi dimensioni come audio e video.

Per aggregazioni di piccole dimensioni (il numero effettivo dei dispositivi audiovisivi dipende dal numero di elaborazioni intermedie e la risoluzione dei singoli dispositivi, in generale 15 è un buon compromesso) è sufficente disporre sul server di un processore \textit{multi core} per l'elaborazione intermedia degli stream audio-video (se necessaria). Per aggregazioni di grandi dimensioni è necessaria una scheda video Nvidia che supporti l'elaborazione tramite CUDA e utilizzare la corretta versione di \srsavlibname.

\subsection{Funzionalità del prodotto}
L'applicazione dovrà disporre di due interfacce separate, una accessibile tramite \textit{http} e una via riga di comando.

All'interfaccia http avranno accesso gli utenti abilitati a visionare in \textit{real time} lo stato dei vari dispositivi, nonché accedere alle registrazioni. Ogni utente deve essere prima autenticato con apposite credenziali per poterne identificare i permessi di visualizzazione.

L'interfaccia via riga di comando è riservata al solo amministratore del sistema. Anch'essa richiede l'inserimento di una password d'amministratore per evitare eventuali manomissioni.

La gerarchia dei dispositivi è gestita sotto forma di albero, ovvero ogni dispositivo può essere aggregato in un gruppo che può a sua volta appartenere ad un'altro gruppo. Non sono ammesse relazioni ricorsive tra gruppi. Tutti i gruppi/dispositivi sono figli (diretti o indiretti) di un gruppo radice. In \hyperref[fig:gerarchia]{figura \ref{fig:gerarchia}} si può osservare un esempio di organizzazione gerarchica di dispositivi e gruppi.

Gli utenti con i giusti permessi e l'amministratore possono gestire la gerarchia, operando spostamenti, rinomine, cancellazioni e aggiunte di dispositivi e gruppi.

Per ogni gruppo è sufficiente memorizzarne solamente il nome e una descrizione.

Per ogni dispositivo invece è necessario memorizzarne il nome, una descrizione, il percorso dove salvare le registrazioni e il periodo di salvataggio. Inoltre può essere specificata anche una operazione intermedia, che per dispositivi audio-video può essere una operazione di transcodifica (utilizzando quindi \srsavlibname) da un formato ad un altro oppure, nel caso di sensori con risultati numerici, una formula matematica (ad esempio il sensore restituisce i gradi su scala Celsius, ma l'utente vuole memorizzare i gradi in scala Kelvin).

\begin{figure}[h]
    \caption{Esempio di una possibile gerarchia di dispositivi (nei rettangoli) e gruppi (negli ovali)}
    \centering
    \includegraphics[width=\textwidth]{1-gerarchia}
    \label{fig:gerarchia}
\end{figure}

\subsection{Caratteristiche degli utenti}
Gli utenti che si interfacceranno con l'applicazione sono l'amministratore e gli utenti generali. L'amministratore ha completo accesso su tutte le parti della applicazione (sia nell'interfaccia web, sia nell'interfaccia a riga di comando). Gli utenti generali avranno dei determinati permessi a loro assegnati per l'utilizzo dell'interfaccia web.

L'utente amministratore deve avere un ottimo grado di dimestichezza con la macchina \textit{Server} su cui configura l'applicazione, sia dal punto di vista del sistema operativo, sia in campo di reti e telecomunicazione, sia nell'ottica di configurazione di programmi via riga di comando, sia, infine, in campo di formati multimediali audio-video. È sufficiente un diploma di tecnico/perito informatico; è consigliata una laurea in campo informatico.

Gli utenti generali sono, invece, di tipo eterogeneo. È comunque necessario che essi sappiano utilizzare un \textit{personal computer} nelle sue funzioni ad altissimo livello (nel senso di comprendere le interfacce grafiche e la loro navigazione) dimodoché siano in grado di utilizzare un \textit{browser web} per l'accesso all'applicazione. Per essi non sono necessarie competenze avanzate in campo di informatica, ma sono consigliate.
\subsection{Vincoli e limiti}
L'applicazione è limitata e/o vincolata nel suo funzionamento da:
\begin{itemize}
    \item La memoria massima di archiviazione dei dati.
    \item Il numero di thread o core del processore e/o la potenza di calcolo della GPU.
    \item Le funzioni e i metodi che \textit{\srsavlibname} mette a disposizione.
    \item La banda massima supportata dalla connessione ad internet, nonché la banda massima della rete locale.
    \item Le politiche di privacy necessarie per memorizzare dati basilari di utenti (e-mail, username e password).
    \item La presenza sul server di una \textit{Java Virtual Machine}.
    \item La presenza sul client di un \textit{browser web}
\end{itemize}
\subsection{Presupposti e dipendenze}
\label{sec:dipendenze}
Il progetto dipende dai progetti \textit{\srsdbname} e \textit{\srsavlibname}, utilizza il protocollo ip e i protocolli che si appoggiano ad esso (http, udp, rtsp etc) e supporta solo macchine \textit{x86} e \textit{amd64} con sistema operativo Microsoft Windows, Linux, macOS. I browser supportati dall'interfaccia web sono Microsoft Edge, Apple Safari, Mozilla Firefox, Google Chrome (e suoi derivati, es: Chromium, Opera etc).
Queste dipendenze possono portare al cambiamento del presente documento e, di conseguenza, all'applicazione.
\subsection{Requisiti futuri}
In futuro può essere necessario supportare più protocolli e più dispositivi. Può essere utile implementare una comunicazione tra l'applicazione e sistemi di \textit{smart home} come Amazon Echo.
\section{Specifica dei requisiti}
\label{sec:specifica}
\subsection{Interfacce con l'esterno}

\begin{center}
    \srseitable{01}{Database}{Gerarchia dispositivi}{L'applicazione riceve in formato JSON la lista di dispositivi, gruppi e la loro organizzazione gerarchica.}{JSON}{Input}

    \srseitable{02}{Dispositivi}{Stream dati}{L'applicazione riceve dai dispositivi attivi uno stream di dati.}{Il formato dati dipende dal protocollo utilizzato dal dispositivo}{Input}

    \srseitable{03}{Server}{Interfaccia web}{L'applicazione invia ai client le pagine HTML tramite http.}{HTML5 \cite{html5}, via http}{Output}
    
    \srseitable{04}{Client}{Interfaccia web}{L'applicazione riceve dai client le richieste tramite http.}{JSON, via http}{Input}
    
    \srseitable{05}{Server}{Riga di comando}{L'applicazione riceve i comandi da riga di comando}{ASCII}{Input}

    \srseitable{06}{Server}{Archiviazione dati}{L'applicazione salva i dati nell'archivio}{Dati binari}{Output}
    
\end{center}

\subsection{Requisiti funzionali}

\begin{center}
    \srsfrtable{01}{Gestione elementi}{Aggiunta}{Nome iniziale dell'elemento}{Da web: l'utente clicca sul bottone ``aggiungi'', un popup chiede il nome iniziale, l'utente sceglie se annullare l'operazione o confermarla.\newline
    Da riga di comando: l'utente scrive il comando apposito per aggiungere un elemento.}{L'elemento viene memorizzato sul database e viene visualizzato sulla interfaccia web o con il comando di elenco degli elementi.}

    \srsfrtable{02}{Gestione elementi}{Modifica}{Dati aggiornati dell'elemento}{Da web: l'utente clicca con il tasto destro sull'elemento da modificare e sceglie ``modifica'', un popup chiede i dati, l'utente sceglie se annullare l'operazione o confermarla.\newline
    Da riga di comando: l'utente scrive il comando apposito per modificare un elemento.}{L'elemento viene aggiornato sul database e viene aggiornato sulla interfaccia web e con il comando di elenco degli elementi.}

    \srsfrtable{03}{Gestione elementi}{Eliminazione}{Elemento da eliminare}{Da web: l'utente clicca con il tasto destro l'elemento da eliminare e sceglie ``elimina''; un popup chiede conferma.\newline
    Da riga di comando: l'utente scrive il comando apposito per eliminare un elemento.}{L'elemento viene eliminato sul database e le sue registrazioni vengono eliminate}

    \srsfrtable{04}{Gestione elementi}{Assegnazione gruppo}{Elemento figlio e gruppo padre}{Da web: l'utente trascina l'\textit{handle} presente sopra l'elemento figlio e lo rilascia sul gruppo padre.\newline
    Da riga di comando: l'utente scrive il comando apposito per assegnare un elemento figlio ad un gruppo padre.}{L'elemento padre dell'elemento figlio viene aggiornato e si aggiorna anche la vista sul web.}

    \srsfrtable{06}{Gestione Elementi}{Visualizzazione}{Dispositivo da visualizzare}{Da web: l'utente clicca due volte sull'elemento da visualizzare.}{I dati vengono visualizzati.}

    \srsfrtable{07}{Autenticazione utente}{Login}{Username e password}{Da web: l'utente clicca sul bottone ``login'', un popup chiede username e password, l'utente sceglie se annullare l'operazione o confermarla.}{Se username e password corretti l'utente accede al sistema.}

    \srsfrtable{08}{Autenticazione utente}{Aggiunta utente}{Username}{Da riga di comando: l'amministratore aggiunge un utente con un determinato username utilizzando il comando apposito.}{L'utente viene aggiunto al sistema con una password temporanea che viene mostrata a video all'amministratore.}

\end{center}

\subsection{Requisiti non funzionali}
\begin{center}
    \srsnrtable{01}{Prestazioni}{Tempo di risposta}{L'interfaccia web deve rispondere in al massimo 5 secondi nell'80\% dei casi. Nel caso la connessione sia lenta deve mostrarne l'avanzamento.}
    
    \srsnrtable{02}{Sicurezza}{Protezione dati}{L'applicazione deve garantire la sicurezza dei dati che gestisce secondo normative internazionali.}
    
    \srsnrtable{03}{User experience}{Interfaccia grafica}{L'applicazione deve offrire l'interfaccia web in modo elegante e comprensibile anche da parte degli utenti meno esperti}
    
    \srsnrtable{04}{User experience}{Guida}{L'applicazione deve mettere a disposizione una guida nella interfaccia grafica in modo da facilitarne l'uso da parte degli utenti meno esperti}
    
    \srsnrtable{05}{Ecosistema}{Scalabilità}{L'applicazione deve essere in grado di sostenere un numero di elementi sempre crescente e gestire correttamente eventuali upgrade all'hardware del Server}
\end{center}
\section{Appendice}
\label{sec:appendice}
\subsection{Tabelle dimensione stream registrati}
    Di seguito vengono riportate alcune tabelle utili per stimare la grandezza totale su disco delle registrazioni dei dispositivi. Si rammenta che le misure sono a solo scopo illustrativo e dipendono da più fattori incalcolabili a priori; inoltre la lista di formati non è da considerarsi esaustiva. Nel caso di dati audiovisivi, è necessario sommare la dimensione al minuto dei rispettivi formati.


    \bigskip
    
    \begin{tabular}{|m{\srsrtcoll}|m{\srsrtcoll}|}
        \hline
        \multicolumn{2}{|m{\srsrtmcol}|}{Audio} \\
        \hline
        Wav PCM 16 bit @44.1kHz stereo & 10 MB/min \\
        \hline
        Flac @44.1kHz stereo & 5 MB/min \\
        \hline
        mp3 @128kbps, 44.1kHz stereo & 1 MB/min \\
        \hline
        ogg @128kbps, 44.1kHz stereo & 1 MB/min \\
        \hline
    \end{tabular}

    \bigskip
    
    \begin{tabular}{|m{\srsrtcoll}|m{\srsrtcoll}|}
        \hline
        \multicolumn{2}{|m{\srsrtmcol}|}{Video} \\
        \hline
        h.264 1920x1080 & 741 MB/min \\
        \hline
        h.264 1280x720 & 444 MB/min \\
        \hline
        h.264 720x486 & 230 MB/min \\
        \hline
    \end{tabular}

    \bigskip

    \begin{tabular}{|m{\srsrtcoll}|m{\srsrtcoll}|}
        \hline
        \multicolumn{2}{|m{\srsrtmcol}|}{Dati} \\
        \hline
        1 sample al millisecondo, 32 bit floating point & 240 kB/min \\
        \hline
        1 sample al secondo, 32 bit floating point & 240 B/min \\
        \hline
        1 sample al minuto, 32 bit floating point & 1 B/min \\
        \hline
        1 sample all'ora, 32 bit floating point & 1 B/ora \\
        \hline
    \end{tabular}

\subsection{Esempio di sintassi da riga di comando}
Aggiunta di un dispositivo generico:\\
\lstinline{device add <name>}\\
dove \textit{name} identifica il nome del nuovo dispositivo da aggiungere.\\[2em]
Modifica campi di un dispositivo generico:\\
\lstinline{device set <field> <value>}\\
dove \textit{field} identifica il nome del campo da modificare e \textit{value} il valore da assegnare al campo.\\[2em]
Eliminazione di un dispositivo generico:\\
\lstinline{device delete <name>}\\
dove \textit{name} identifica il nome del dispositivo da eliminare.\\[2em]
Aggiunta, modifica, eliminazione di un gruppo:\\
\lstinline{group add <name>}\\
\lstinline{group set <field> <value>}\\
\lstinline{group delete <name>}\\[2em]
Aggiunta di un figlio ad un gruppo:\\
\lstinline{group addchild <parentgroup> <name>}\\
dove \textit{parentgroup} è il nome del gruppo a cui assegnare l'elemento con nome \textit{name}.\\

\subsection{Design}
\subsubsection{Use Case}
\begin{figure}[H]
    \caption{Use case diagram dell'applicazione}
    \centering
    \includegraphics[width=\textwidth]{2-usecase}
    \label{fig:usecase}
\end{figure}
\subsubsection{Design pattern}
In figura \ref{fig:classes} si può osservare una vista di insieme delle relazioni tra le classi di una parte della applicazione. Il diagramma non è da considerarsi esaustivo (ad esempio non sono riportati tutti gli algoritmi di codifica/tutte le espressioni).

In seguito verranno, poi, analizzate parti del diagramma per identificare e spiegare i vari pattern utilizzati.
\begin{figure}[H]
    \caption{Class diagram non esaustivo di una parte di applicazione}
    \centering
    \includegraphics[width=\textwidth]{3-classes}
    \label{fig:classes}
\end{figure}

{%
\setlength\intextsep{0pt}
\begin{wrapfigure}{r}{\srswrapfigwidth}
    \caption{Composite}
    \centering
    \includegraphics[width=\srswrapfigwidth]{3a-composite}
    \label{fig:composite}
\end{wrapfigure}
\paragraph{Composite}
La gerarchia dei gruppi e dei dispositivi è modellata utilizzando il design pattern ``Composite'', mostrato in figura \ref{fig:composite}. Esso prevede che gli elementi della gerachia vengano trattati allo stesso modo e li rappresenta sotto forma di albero, in linea con quanto richiesto nei requisiti. Si è deciso di tenere l'implementazione dei dispositivi separata dalla gerarchia utilizzando un ``Bridge pattern'', la cui discussione è oggetto del paragrafo seguente.

\paragraph{Bridge}
Per evitare che la gerarchia dei dispositivi cresca in modo incontrollabile e per promuovere la composizione sull'ereditarietà, si è deciso di utilizzare il design pattern ``Bridge'' (in figura \ref{fig:bridge}) per separare l'astrazione del dispositivo dalla sua effettiva implementazione. Nel diagramma vengono mostrate due possibili implementazioni del dispositivo, ovvero il ``sensore'' e il dispositivo ``audiovisivo''.
\begin{figure}[H]
    \caption{Bridge}
    \centering
    \includegraphics[width=\textwidth]{3b-bridge}
    \label{fig:bridge}
\end{figure}

\setlength\intextsep{0pt}
\begin{wrapfigure}{r}{\srswrapfigwidth}
    \caption{Decorator}
    \centering
    \includegraphics[width=\srswrapfigwidth]{3c-decorator}
    \label{fig:decorator}
\end{wrapfigure}
\paragraph{Decorator}
Per gestire in modo flessibile le operazioni di codifica e decodifica degli stream dei dispositivi si è deciso di implementare il design pattern del ``Decorator'' (figura \ref{fig:decorator}) in quanto è anche il pattern utilizzato da Java per aggiungere funzionalità agli stream. Per questo stesso motivo il decorator viene utilizzato in giunzione al pattern ``Strategy'' (la discussione è nel paragrafo seguente), in modo da evitare di dover creare tante classi derivate dai decorator rischiando di dover ripetere del codice; ancora una volta si opta per la composizione invece che l'ereditarietà.

\setlength\intextsep{0pt}
\begin{wrapfigure}{r}{\srswrapfigwidth}
    \caption{Strategy}
    \centering
    \includegraphics[width=\srswrapfigwidth]{3d-strategy}
    \label{fig:strategy}
\end{wrapfigure}
\paragraph{Strategy}
In figura \ref{fig:strategy} viene esposto l'utilizzo dello strategy pattern nella definizione degli algoritmi di decodifica (per la codifica si applica lo stesso pattern con le stesse considerazioni). Si noti l'esistenza di un algoritmo chiamato ``NoDecode'', il quale semplicemente restituisce lo stream non decodificato, ovvero non ne modifica i byte. Particolare attenzione è da riservare all'algoritmo ``DecodeByExpr'', il quale è utile per modellare la richiesta di applicare delle funzioni ai valori dei sensori; esso lavora in sinergia con il pattern ``Interpreter'' che viene analizzato nel prossimo paragrafo.

\setlength\intextsep{0pt}
\begin{wrapfigure}{r}{\srswrapfigwidth}
    \caption{Interpreter}
    \centering
    \includegraphics[width=\srswrapfigwidth]{3e-interpreter}
    \label{fig:interpreter}
\end{wrapfigure}
\paragraph{Interpreter}
Come anticipato nel paragrafo precedente, l'applicazione di una funzione al valore di un sensore è implementata tramite il design pattern ``Interpreter''. Esso modella una grammatica tramite un albero e permette, quindi, di costruire una espressione matematica in modo ricorsivo. Nel diagramma di figura \ref{fig:interpreter} vengono mostrate alcune operazioni e alcuni operandi d'esempio come la somma, il prodotto, il logaritmo, la costante e il valore del sample stesso (che viene passato come ``Contesto'' del calcolo).

Di seguito viene mostrato un possibile object diagrame e un sequence diagram per la risoluzione di una espressione da parte dell'interpreter; inoltre viene proposto in pseudo codice Java una possibile implementazione di alcune classi dello stesso.

\begin{figure}[H]
    \caption{Object diagram di una espressione d'esempio}
    \centering
    \includegraphics[width=\textwidth]{4a-interpreterexample}
    \label{fig:interpreterexamplea}
\end{figure}

\begin{figure}[H]
    \caption{Sequence diagram della risoluzione dell'espressione di figura \ref{fig:interpreterexamplea} con valore di $x=100$}
    \centering
    \includegraphics[width=\textwidth]{4b-interpreterexample}
    \label{fig:interpreterexampleb}
\end{figure}
%}

\begin{small}
\begin{lstlisting}{language=Java}
    public abstract class Expression {
        public abstract float calculate(float x);
    }

    public final class ConstantExpression extends Expression {
        private final float value;
        public ConstantExpression(float value) {
            this.value = value;
        }
        public final float calculate(float x) {
            return this.value;
        }
    }

    public final class SampleValueExpression extends Expression {
        public final float calculate(float x) {
            return x;
        }
    }

    public final class SumExpression extends Expression {
        private final Expression add1;
        private final Expression add2;
        public SumExpression(Expression add1, Expression add2){
            this.add1 = add1;
            this.add2 = add2;
        }
        public final float calculate(float x){
            final float a = this.add1.calculate(x);
            final float b = this.add2.calculate(x);
            return a + b;
        }
    }

    public final class ProductExpression extends Expression {
        private final Expression fac1;
        private final Expression fac2;
        public ProductExpression(Expression fac1, Expression fac2){
            this.fac1 = fac1;
            this.fac2 = fac2;
        }
        public final float calculate(float x){
            final float a = this.fac1.calculate(x);
            final float b = this.fac2.calculate(x);
            return a * b;
        }
    }

    public final class LogExpression extends Expression {
        private final Expression base;
        private final Expression arg;
        public LogExpression(Expression base, Expression arg){
            this.base = base;
            this.arg = arg;
        }
        public final float calculate(float x){
            final float a = this.arg.calculate(x);
            final float b = this.base.calculate(x);
            return (float)(Math.log(a) / Math.log(b));
        }
    }
\end{lstlisting}
\end{small}

\paragraph{Altri pattern implementabili}
I pattern sopra proposti sono un esempio dei tanti che si possono utilizzare per questa applicazione; ad esempio si potrebbe pensare di implementare la comunicazione coi dispositivi attraverso un ``Proxy'' in modo da gestire al meglio il traffico. Un altro pattern implementabile è il ``Command'' per gestire le operazioni di management della gerarchia. Non sono stati presentati pattern di creazione come ``Abstract Factory'', ``Singleton'' etc, ma hanno anch'essi una applicazione in questo progetto.

\subsubsection{Activity Diagram}
Viene riportato un activity diagram relativo alla modifica di un elemento nella gerarchia da parte di un utente che sta utilizzando l'interfaccia web.
\begin{figure}[H]
    \caption{Activity diagram relativo alla modifica}
    \centering
    \includegraphics[width=\textwidth]{5-activitydiagrammodifica}
    \label{fig:activitydiagram}
\end{figure}

\end{document}